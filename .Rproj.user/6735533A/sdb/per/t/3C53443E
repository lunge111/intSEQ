{
    "collab_server" : "",
    "contents" : "\nintSEQ.default <- \n  function(count.data, cond,nneighbour=400,lambda1 =ncol(count.data),lambda2 =0.05, meanmeth=c(\"estimator\",\"local.mean\")\n           ,smoothmethod = c(\"loess\",\"spline\",\"no\"),normalize=TRUE, coeff =c(2), offsets = NULL, weights = NULL, constadj=FALSE,...) {\n    meanmeth=match.arg(meanmeth)\n    smoothmeth=match.arg(smoothmethod)\n    if( normalize){\n      normfac <- calcNormFactors(count.data,method = \"TMM\")\n      libsize=colSums(count.data)\n      #get normalization factors\n      norm.fac <-libsize*normfac/(mean(normfac*libsize))\n    }else{\n      norm.fac <- rep(1, ncol(count.data))\n    }\n    #estimate the dispersion using edgeR without shrinking\n    design <- model.matrix(~cond)\n    design0=design[,-coeff,drop=F]\n    if(is.null(offsets)) offsets=rep(0, ncol(count.data))\n    d <- estimateGLMTrendedDisp(count.data, design,offset=log(norm.fac)+offsets, weights = weights)\n    d <- estimateGLMTagwiseDisp(count.data, design, prior.df = 0.0, offset=log(norm.fac)+offsets, weights = weights, dispersion = d)\n    disper <- d\n    \n    fit.full <- glmFit(count.data,design , offset=log(norm.fac), dispersion = disper)\n    fit.null <- glmFit(count.data,design0 , offset=log(norm.fac), dispersion = disper) \n    full.lr <- glmLRT(fit.full, coef = coeff)\n    res = topTags(full.lr,n=nrow(count.data), sort.by = \"none\")$table\n    \n    beta=fit.full$unshrunk.coefficients\n    beta0=fit.null$unshrunk.coefficients \n    eta=beta%*%t(design)\n    eta0=beta0%*%t(design0)\n    eta=t(apply(eta,1, function(x,y) x+y, y=log(norm.fac)))\n    eta0=t(apply(eta0,1, function(x,y) x+y, y=log(norm.fac)))\n    mu0=exp(eta0)\n    mua=exp(eta)\n    means=rowMeans(count.data)\n    if(constadj){\n      constvec = dnbinom(x = floor(means), size = 1/disper, mu=means)\n    }else{\n      constvec=rep(1, length(means))\n    }\n   \n    \n    #remove outliers before fit the smooth line, the dispersions are\n    #larger than 99% quantile +2* interquartile or extremely small are removed\n    newdisper=disper\n    newdisper[disper<=1e-3] <-NA\n    newdisper[disper > quantile(disper,probs=0.99,na.rm=T)+2* IQR(disper, na.rm = T)] <- NA\n    keep = !is.na(newdisper)\n    newdisper <- newdisper[keep]\n    newmeans <- means[keep]\n    #fit a smooth line of started log of means versus dispersion\n    \n    df=data.frame(x=log(newmeans+0.5,base=2),y=newdisper)\n    smooth.fit <- switch(smoothmeth,\n                         loess = loess(y~x,data=df, span=0.4),\n                         spline = smooth.spline(x=log(newmeans+0.5,base=2),y=newdisper, spar=0.4),\n                         no = NULL)\n    mdf=data.frame(\"x\"=log(means+0.5,base=2))\n    fitted.disp  <- switch(smoothmeth,\n                           loess = predict(smooth.fit,mdf),\n                           spline = predict(smooth.fit,x=log(means+0.5,base=2))$y,\n                           no = NULL)\n    \n    rk<- rank(means)\n    lr=numeric(length(disper))\n    \n    for(i in 1:length(disper)){\n      if(i <=nneighbour/2){\n        index = (rk<=(nneighbour+1))\n      }else if(i >= length(disper)-nneighbour/2){\n        index = (rk >= (length(disper)-nneighbour))\n      }else{\n        index = (rk>=(rk[i]-nneighbour/2))&(rk<=(rk[i]+nneighbour/2))\n      }\n      data=count.data[i,]\n      thetas <- disper[index]\n      if(smoothmeth==\"no\"){\n        is.smooth=FALSE\n      }else{is.smooth=T\n      fitted.disps=fitted.disp[index]\n      }\n      lr[i]<-marginal.LR(thetas = thetas, disp.fit = fitted.disps ,data=data, cond=cond,thet = disper[i]\n                         , fit.thet = fitted.disp[i],lambda1,lambda2 ,meanmeth,is.smooth,m0=mu0[i,],ma=mua[i,],const = constvec[i])\n    }\n    \n    pval =  pchisq(lr,df=length(coeff),lower.tail = F)\n    res$intLR = lr\n    res$intPValue = pval\n    res$\"FDR\" = p.adjust(pval, method = \"fdr\")\n    res<- res[ ,c(\"logFC\",  \"logCPM\", \"FDR\" , \"intLR\", \"intPValue\", \"LR\", \"PValue\")]\n    res[is.nan(pval), c(\"intLR\",\"intPValue\")] <- res[is.nan(pval), c(\"LR\", \"PValue\")] \n    name <-   colnames(res)\n    name[match(c(\"LR\", \"PValue\"), name)] <- c(\"ordinaryLR\", \"ordinaryPValue\")\n    colnames(res) <- name\n    par <- cbind(mua, disper)\n    colnames(par) <- c(paste(\"mu\", 1:ncol(mua)), \"disper\")\n    res=list(restable = res, parameters = par, cond = cond )\n  class(res) <- \"intres\"\n  res\n    }",
    "created" : 1518420447094.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2144742215",
    "id" : "3C53443E",
    "lastKnownWriteTime" : 1518352778,
    "last_content_update" : 1518352778,
    "path" : "E:/package/intSEQ/R/intSEQ.default.R",
    "project_path" : "R/intSEQ.default.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}